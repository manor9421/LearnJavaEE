<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd"
	>
	<!-- для всех бинов будут такие destroy и init методы(если выше указать)
	default-init-method="initObject"
	default-destroy-method="destroyObject"
	default-lazy-init="true" - lazy init
	 -->

	<!-- через "p" можно писать пропертис, если подключить класс(см выше в обьявлении).
		prototype - каждый раз, когда будем вызывать .getBean, будет создаваться НОВЫЙ объект
		Если убрать scope, то .getBean будет возвращать ОДИН и тот же объект:
			ModelT1000 t1000 = (ModelT1000) context.getBean("t1000");
			t1000 = (ModelT1000) context.getBean("t1000");
		init и destroy-методы отрабатывают при создании и уничтожении бинов
		lazy-init - чтобы при создании первого бина не срабатывал init и на этом,
		и он не занимал память. т.к. по-умолчанию он срабатывает для всех описанных,
		depends-on - создасться только ПОСЛЕ инициализации databaseBean
		parent="baseModel" - унаследовать все, что имеет baseModel -->
	<bean id="t1000"
		class="ru.javabegin.training.spring.impls.robot.ModelT1000"
		
		p:hand-ref="toshibaHand"
		p:leg-ref="sonyLeg"
		p:head-ref="sonyHead"
		
		init-method="initObject"
		destroy-method="destroyObject"
		
		scope="prototype"
		lazy-init="true"
		depends-on="databaseBean"
		
		>
		<!-- должно соответствовать конструктору, index - если указываем ЗДЕСЬ не по порядку.
			type - по желанию 
		<constructor-arg ref="sonyHand"/>
		<constructor-arg ref="sonyLeg"/>
		<constructor-arg ref="sonyHead"/> -->
		<constructor-arg value="silver" index="0" type="String"/>
		<constructor-arg value="2006" index="1" type="int"/>
		<constructor-arg value="true" index="2" type="boolean"/>
		
		<!-- Не смотря на то, что можно и так и так, property в приоритете.
			Потому что это get/setters, и мы НАЗНАЧАЕМ новые значения после создания -->
		<!-- <property name="hand" ref="toshibaHand"/> -->
		<!-- <property name="head" ref="toshibaHead"/> -->
		<!-- <property name="leg" ref="toshibaLeg"/> -->
	</bean>
	
	<!-- приписка "Empty" не обязательно, но для нас значит, что будет использоваться конструктор БЕЗ обьектов. только тот, что с примитивными типами -->
	<bean id="t1000Empty"
		class="ru.javabegin.training.spring.impls.robot.ModelT1000"
		lazy-init="true"
		parent="baseModel" >

		<constructor-arg value="silver" index="0" type="String"/>
		<constructor-arg value="2006" index="1" type="int"/>
		<constructor-arg value="true" index="2" type="boolean"/>

	</bean>
	
	<!-- указываем, что бин - как абстрактный класс. И его уже наследуем.
	Можно и без abstract. наследует только свойства и конструкторы, но не методы -->
	<bean id="baseModel" abstract="true">
	
		<constructor-arg ref="sonyHand" index="0"/>
		<constructor-arg ref="sonyLeg" index="1"/>
		<constructor-arg ref="sonyHead" index="2"/>
	</bean>

	<bean id="sonyHead"
		class="ru.javabegin.training.spring.impls.sony.SonyHead"/>
	<bean id="sonyHand"
		class="ru.javabegin.training.spring.impls.sony.SonyHand"/>
	<bean id="sonyLeg"
		class="ru.javabegin.training.spring.impls.sony.SonyLeg"/>
	
	<bean id="toshibaHead"
		class="ru.javabegin.training.spring.impls.toshiba.ToshibaHead"/>
	<bean id="toshibaHand"
		class="ru.javabegin.training.spring.impls.toshiba.ToshibaHand"/>
	<bean id="toshibaLeg"
		class="ru.javabegin.training.spring.impls.toshiba.ToshibaLeg"/>
		
	<bean class="ru.javabegin.training.spring.main.MyBeanPostProcessor">
	</bean>
	
	<bean id="databaseBean" class="ru.javabegin.training.spring.impls.Database"/>
	
	<bean id="t1000a" class="ru.javabegin.training.spring.impls.robot.ModelT1000" parent="baseModel" scope="prototype">

		<constructor-arg value="silver" index="3" type="String" />
		<constructor-arg value="2005" index="4" type="int" />
		<constructor-arg value="true" index="5" type="boolean" />		

	</bean>
	
	<bean id="actionReplacer" class="ru.javabegin.training.spring.impls.robot.ActionReplacer" />
	
	<bean id="t1000Conveyor" class="ru.javabegin.training.spring.impls.conveyor.T1000Conveyor">
		<!-- передать в абстрактный метод createRobot(абстрактного класса T1000Conveyor)
			значение t1000a.
			теперь вызов метода createRobot будет создавать новый экземпляр
			T1000a, т.к. он - prototype -->
		<!-- <lookup-method name="createRobot" bean="t1000a" /> -->
		<!-- заменить метод action на actionReplacer -->
		<replaced-method name="action" replacer="actionReplacer" />
		
	</bean>
	
	
	<!-- import файла, содержащего бины. Часто разделяются по конфигурациям, а не по объектам. Напр, для работы с базой, для работы с вебом и т.д.
	<import resource="t1000_context.xml" />
	то же самое можно делать и в pom.xml -->
</beans>
